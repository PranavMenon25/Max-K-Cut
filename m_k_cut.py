# -*- coding: utf-8 -*-
"""M-K Cut

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1401toNKjaEGK6lFrOuv2vKoFBcqPv1aj
"""

import networkx as nx
import random

G = nx.Graph()

nodes = [1,2,3,4,5,6]
edges = [(1,6), (1,2), (2,3), (3,4), (4,5), (5,3), (1,4)]

G.add_nodes_from(nodes)

G.add_edges_from(edges)

G = nx.erdos_renyi_graph(200, 0.3)
nodes = G.nodes()
edges = G.edges()

import matplotlib.pyplot as plt
nx.draw(G, with_labels=True)
plt.show()

import numpy as np

J = nx.to_numpy_array(G)

# Converting the adjacency to the matrix as in question
i = 0
j = 0
size = J.shape
for i in range(size[0]):
  for j in range(size[1]):
    if(J[i][j] == 1):
      J[i][j] = -1

J

import random

def random():
  return np.random.randint(1,4)

# Assigning random vector

states = []

for i in range(len(nodes)):
  state = random()
  if(state == 1):
    p = np.array([1,0,0])
    states.append(p)
  elif(state == 2):
    p = np.array([0,1,0])
    states.append(p)
  else:
    p = np.array([0,0,1])
    states.append(p)

# states = np.array([[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0]])
# states

optimum_ans = states
for i in range(G.number_of_nodes()):
  states[i] = [1,0,0]

def find_energy():
  energy = 0
  for i in range(G.number_of_nodes()):
    for j in range(i):
      energy = energy + J[i][j] * int(2*np.dot(states[i], states[j])-1)
  energy = -1 * (energy)
  return energy

min_energy = find_energy()
min_energy

def calc_phi(alpha):
  toRet = 0
  for i in range(G.number_of_nodes()):
    if(i != alpha):
      toRet = toRet + J[alpha][i] * (2*np.dot(states[i], states[alpha])-1)

  return toRet

beta = 1

#importing math for tanh
import math

def synaptic_feed(alpha):
  return (math.tanh(beta * calc_phi(alpha)) - (np.random.uniform(-1,1)))

def all_synaptic_feed():
  toRet = []
  for i in range(G.number_of_nodes()):
    toRet.append(synaptic_feed(i))
  return toRet

synap = all_synaptic_feed()
synap

def find_next_state(alpha):
  sign = 1
  if(synap[alpha] >= 0):
    sign = 1
  else:
    sign = -1
  g = np.random.uniform(0,1)

  if(g>0.5):
    g = 1
  else:
    g = 0
  final1 = 0
  final1 = int(np.dot(states[alpha], np.array([1,0,0]))) * ((0.5 * 1 * (1 + sign)) + (0.5 * 2 * g * (1 - sign))+ (0.5 * 3 * (1 - g) * (1 - sign)))
  final2 = int(np.dot(states[alpha], np.array([0,1,0]))) * ((0.5 * 2 * (1 + sign)) + (0.5 * 3 * g * (1 - sign))+ (0.5 * 1 * (1 - g) * (1 - sign)))
  final3 = int(np.dot(states[alpha], np.array([0,0,1]))) * ((0.5 * 3 * (1 + sign)) + (0.5 * 1 * g * (1 - sign))+ (0.5 * 2 * (1 - g) * (1 - sign)))
  final = (final1 + final2 + final3)
  if(final == 1):
    return np.array([1,0,0])
  elif(final == 2):
    return np.array([0,1,0])
  else:
    return np.array([0,0,1])

def find_cut():
  cut = 0
  for i in edges:
    cut = cut + 1 - np.dot(states[i[0]], states[i[1]])
  return cut

print(G.number_of_edges())
find_cut()

cut = []
energy = []
for i in range(100):
  synap = all_synaptic_feed();
  for j in range(G.number_of_nodes()):
    states[j] = find_next_state(j)
  l = find_energy()
  stat = states
  print(stat, l)
  cut1 = find_cut()
  cut.append(cut1)
  energy.append(l)

print(cut)
print(energy)

x = list(range(1, 101))

plt.plot(x, cut, marker='o', linestyle='-', color='r', label='Max-cut')
plt.title('Cut')
plt.xlabel('Iteration')
plt.ylabel('Cut')
plt.show()

plt.plot(x, energy, marker='o', linestyle='-', color='b', label='Energy')
plt.title('Energy')
plt.xlabel('Iteration')
plt.ylabel('Energy')
plt.show()

